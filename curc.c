#include <stdio.h> //для ввода вывода
#include <stdlib.h>//для динамической памяти
#include <string.h>
int main(int argc, char *argv[]){//главная функция в которую передается имя файла
	char *filename=(char*)malloc(20*sizeof(char));//выделение памяти для названия файла
	unsigned char* sentence_pref;
	unsigned char* sentence;
	if(argc<2){//если имя файла не введено
		printf("\nError file name missed");//вывод ошибки
		printf("\nВведите имя файла: ");
		scanf("%s", filename);
	}
	else filename = argv[1];//иначе используем введенное пользователем имя файла
	FILE * f; //объявление файла
	int count_s=0,count_sum=0,count_toh=0,k=0,b,count_2=0,count_1=0,chek=0,chek_2=0;
	unsigned char s; //символ
	while((f = fopen(filename,"r"))==0){//пока файл не открывается
		printf("\n%s", filename);
		printf("\nerror: file not found");//вывод ошибки
		printf("\nВведите  имя файла: ");
		scanf("%s", filename);
	}
	while(!feof(f)){//пока не конец файла
		s=getc(f);//считываем символ
		b=0;//флаг для проверки
		rewind(f);//возвращаемся в начало
		fseek(f,count_sum,0);//переходим к следующему предложению
		count_s=0;//зануляем
		count_1=0;//зануляем
		count_2=0;//зануляем
		for(int i=0;s!=46 && feof(f)==0;i++){//обработка предложения
			s=getc(f);//считываем символ
			if(s!=46) count_s++;//подсчитываем количество сиволов в предложениии кроме точки, что бы потом перейти к следующему предложению
			if(s!=46 && s!= 10) count_1++;//подсчитываем количество символов кроме переноса на новую строку для определения длинны массива
			//подсчитываем количество сиволов для отредактированного предложения
			//если символ не является  знаком препинания, переносом на новую строку, а так же  не является элементом кодировки русских символов
			if(s!=46 && s!=10 && s!=32 && s!=33 &&s!=44 &&s!=58 && s!=59 && s!=40 && s!=41 &&s!=34 && s!=39 && s!=45 && s!=63 && s<200){
				 count_2++;
			}
		}
		if(s==46|| feof(f)!=0){//если встретилась точка
                        rewind(f);//возвращаемся в начало файла
                        fseek(f,count_sum,0);//переходим к  только что обработаному предложению
                        count_sum=count_sum+count_s;//увеличиваем количество символов, что бы переходить к другому предложению
                }

		count_sum++;
		sentence_pref = (char*)malloc((count_1+1)*sizeof(char));//массив для хранения неизмененного предложения
		sentence = (char*)malloc((count_2+1)*sizeof(char));//массив для обработанного предложения и работы с ним
		s= getc(f);//считывем символ
		for(int i=0,j=0;s!=46 && feof(f)==0;i=i){//заполняем массивы пока не встретися точка или не будет достигнут конец файла
			if(s!=46 && s!=10){//исключаем точку и перенос на новую строку
				sentence_pref[j]=s;//заполняем 1массив
				j++;
			}
			//исключаем все знаки препинания, точки, пробелы, и сиволы кодировки русских символов
                        if(s!=46 && s!=10 && s!=32 && s!=33 &&s!=44 &&s!=58 && s!=59 && s!=40 && s!=41 &&s!=34 && s!=39 && s!=45 && s!=63 && s<200){
				if((s>=144 && s<=175)|| (s>=65 && s<=90)) sentence[i]=s+32;//меняем заглавные буквы на прописные
				else sentence[i] = s;
				i++;
			}
			s=getc(f);//считываем символ
		}
		if(s==0) count_2--;//если встетится знак конца файла, то уменьшит  количество символов на 1
		//проверка на палиндром
		for(int i=0;i<(count_2)/2;i++){//пока i меньше половины длины предложения
			if(sentence[i]!=sentence[(count_2)-1-i]){//если символы попарно не равны, то он не является палиндромом
			b=0;
			break;
			}
			b=1;//флаг для проверки нашелся ли палиндром
		}
		if(b==1){//если палиндром нашелся
			printf("\n%s\n",sentence_pref);//выводим не отредактированное предложение
			chek_2=1;//флаг для проверки есть ли палиндромы в тексте
		}
	}
	free(sentence);//освобождение памяти
        free(sentence_pref);//освобождение памяти
	if(chek_2 == 0) printf("\nПалиндромов нет\n");//если флаг равен 0
	fclose(f);//закрытие файла 
}
